# 设计原理与模式

本 SDK 的设计目标是“少而稳”：以最少的类、最少的状态，覆盖 DJI Cloud API 的关键流程，
让调用端可以自由组合而不被复杂框架束缚。

## 分层结构

- 核心层（core）：`MQTTClient` 负责连接、订阅、消息分发和状态缓存。
- 调用层（core）：`ServiceCaller` 封装请求/响应式调用。
- 服务层（services）：对 DJI Cloud API 的方法做薄封装（控制权、DRC、直播、飞行、相机）。
- 原语层（primitives）：把常用控制动作抽象成可组合原语（飞点、进度监控、摇杆循环）。
- 任务层（tasks）：更高层的任务编排与轨迹执行（MissionRunner、trajectory）。
- 工具层（tools/utils/sample/docs）：调试、脚本、示例与文档。

## 关键设计模式

### 1. 极简核心 + 纯函数服务层

核心只有两个类：`MQTTClient` 与 `ServiceCaller`。
业务逻辑尽量以“纯函数 + 显式输入输出”的形式存在于 `services/`，避免引入复杂对象状态。

好处：
- 入口清晰，学习成本低
- 可测试性强，服务函数易于独立调用
- 易于组合与复用

### 2. 请求/响应统一接口

`ServiceCaller.call(method, data)` 把请求封装为统一入口，屏蔽 MQTT 细节。

好处：
- 调用方式一致，减少心智负担
- 调用者只关心业务参数，不关心 topic 结构

### 3. 状态缓存与轻量锁

`MQTTClient` 将 OSD、状态、事件等信息缓存到内存，并用锁保护并发读写。

好处：
- 不必到处订阅并解析消息
- 读取状态更像“查询”，更直观

### 4. 原语可组合

`primitives/` 把单动作抽成通用函数，例如 `fly_to_waypoint` 和 `monitor_flyto_progress`，
上层可自由拼接为任务流。

好处：
- 灵活，不强制任务框架
- 便于外部系统复用

### 5. 任务层解耦

任务层不是“替代原语”，而是建立在原语之上的可选封装。
如果你的系统已有任务调度，可直接忽略任务层，仅用原语层。

好处：
- 兼容不同业务形态
- 避免被 SDK 的任务模型限制

### 6. DRC 心跳独立

心跳逻辑在 `services/heartbeat.py` 中独立实现，调用端可自行控制频率与线程生命周期。

好处：
- 便于接入现有调度器
- 避免隐式后台线程

## 为什么这样设计

- **最小可用**：先让关键流程跑通，再逐步加能力。
- **低心智负担**：核心只有两个类，入口统一。
- **组合优先**：提供原语而非“完整框架”，便于融入既有系统。
- **可测试**：服务层多为函数，便于隔离测试。

## 适用场景

- 需要快速接入 DJI Cloud API 的业务系统
- 希望 SDK 不干预业务架构
- 需要二次封装或深度定制的团队
